<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Breakout</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
            color: #fff;
        }

        .wood-veneer {
          background: 
              repeating-linear-gradient(0deg,
                  transparent 0px,
                  rgba(25, 17, 11, 0.8) 1px,
                  transparent 2px,
                  transparent 5px,
                  rgba(41, 28, 18, 0.4) 6px,
                  transparent 7px,
                  transparent 10px,
                  rgba(25, 17, 11, 0.6) 11px,
                  transparent 12px,
                  transparent 18px
              ),
              repeating-linear-gradient(0deg,
                  transparent 0px,
                  rgba(62, 42, 27, 0.4) 2px,
                  transparent 3px,
                  transparent 8px,
                  rgba(41, 28, 18, 0.5) 9px,
                  transparent 10px,
                  transparent 14px
              ),
              linear-gradient(95deg, 
                  #3e241a 0%,
                  #6d4228 60%,
                  #6d4228 100%
              );
          border-radius: 8px;
          box-shadow: 
              inset 0 1px 0 rgba(255, 255, 255, 0.05),
              0 4px 20px rgba(0, 0, 0, 0.3);
          position: relative;
          padding: 20px;
        }

        #gameCanvas {
            border: 2px solid #fff;
            background: #1a1a2e;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            display: none;
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #highScores {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translateX(-50%) translateY(-50%);
          background: rgba(0,0,0,0.95);
          padding: 30px;
          border-radius: 10px;
          display: none;
          color: #fff;
          min-width: 400px;
        }
        #highScores h2 {
            margin-top: 0;
            text-align: center;
            color: #FFD700;
        }
        #highScores table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        #highScores th {
            background: rgba(255, 215, 0, 0.2);
            padding: 10px;
            text-align: left;
            border-bottom: 2px solid #FFD700;
        }
        #highScores td {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        #highScores tr.new-score {
            background: rgba(0, 255, 0, 0.2);
            animation: highlight 1s ease-in-out infinite;
        }
        @keyframes highlight {
            0%, 100% { background: rgba(0, 255, 0, 0.2); }
            50% { background: rgba(0, 255, 0, 0.4); }
        }
        #highScores button {
            display: block;
            width: 100%;
            padding: 12px;
            margin-top: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        #highScores button:hover {
            background: #45a049;
        }
    </style>
</head>
<body class="wood-veneer">
    <div id="score">Score: 0</div>
    <div id="gameOver">GAME OVER<br><span style="font-size: 24px;">Press SPACE to restart</span></div>
    <div id="highScores">
        <h2>HIGH SCORES</h2>
        <table id="scoresTable">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Score</th>
                    <th>Meetings</th>
                    <th>Date</th>
                </tr>
            </thead>
            <tbody id="scoresBody">
            </tbody>
        </table>
        <button onclick="closeHighScores()">Continue (SPACE)</button>
    </div>
    <canvas id="gameCanvas" width="1200" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const gameOverEl = document.getElementById('gameOver');
        const highScoresEl = document.getElementById('highScores');
        const scoresBodyEl = document.getElementById('scoresBody');

        // Game configuration
        const MAX_HIGH_SCORES = 10;
        let newHighScoreIndex = -1;
        const NUM_BALLS = 5; // Configure number of balls in play
        const BRICK_COLS = 15;
        const BRICK_PADDING = 3;
        const BRICK_OFFSET_TOP = 80;
        const BRICK_OFFSET_LEFT = 20;
        const BRICK_WIDTH = (canvas.width - BRICK_OFFSET_LEFT * 2 - BRICK_PADDING * (BRICK_COLS - 1)) / BRICK_COLS;
        const BASE_BRICK_HEIGHT = 25;
        
        const PADDLE_WIDTH = 120;
        const PADDLE_HEIGHT = 15;
        const PADDLE_Y = canvas.height - 40;
        const PADDLE_SPEED = 10;
        
        const BALL_RADIUS = 5;
        const BALL_BASE_SPEED = 5;
        
        const DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
        
        const MEETING_TITLES = [
            'Standup',
            '1:1',
            'Product Review',
            'Sprint Planning',
            'Client Call',
            'Design Sync',
            'Budget Review',
            'All Hands',
            'Engineering Sync',
            'Marketing Brief',
            'Sales Update',
            'Strategy Session',
            'Retrospective',
            'Interview',
            'Training',
            'Board Meeting',
            'Vendor Demo',
            'Code Review',
            'Architecture',
            'Customer Feedback',
            'Planning',
            'Quarterly Review',
            'Team Lunch',
            'Performance Review'
        ];
        
        const MEETING_COLORS = [
            '#4285F4', '#EA4335', '#FBBC04', '#34A853', 
            '#FF6D00', '#9C27B0', '#00897B', '#D81B60',
            '#3F51B5', '#E91E63', '#009688', '#FF5722'
        ];

        let gameState = {
            score: 0,
            gameOver: false,
            won: false,
            meetingsDestroyed: 0,
            paddle: {
                x: canvas.width / 2 - PADDLE_WIDTH / 2,
                vx: 0
            },
            balls: [],
            bricks: [],
            keys: {}
        };

        function createBricks() {
            const bricks = [];
            const colsPerDay = 3;
            
            for (let day = 0; day < 5; day++) {
                const dayStartCol = day * colsPerDay;
                let currentRow = 0;
                
                // Random number of meetings per day (5-8)
                const numMeetings = Math.floor(Math.random() * 4) + 5;
                
                for (let m = 0; m < numMeetings; m++) {
                    // Random height: 1-4 rows tall
                    const rowSpan = Math.floor(Math.random() * 4) + 1;
                    const height = rowSpan * BASE_BRICK_HEIGHT + (rowSpan - 1) * BRICK_PADDING;
                    
                    // Random width: 1-3 columns wide
                    const colSpan = Math.min(Math.floor(Math.random() * 3) + 1, colsPerDay);
                    const width = colSpan * BRICK_WIDTH + (colSpan - 1) * BRICK_PADDING;
                    
                    const y = BRICK_OFFSET_TOP + currentRow * (BASE_BRICK_HEIGHT + BRICK_PADDING);
                    
                    // Stop if we're getting too tall
                    if (y + height > 350) break;
                    
                    bricks.push({
                        x: BRICK_OFFSET_LEFT + dayStartCol * (BRICK_WIDTH + BRICK_PADDING),
                        y: y,
                        width: width,
                        height: height,
                        title: MEETING_TITLES[Math.floor(Math.random() * MEETING_TITLES.length)],
                        color: MEETING_COLORS[Math.floor(Math.random() * MEETING_COLORS.length)],
                        day: DAYS[day],
                        active: true,
                        points: rowSpan * 10
                    });
                    
                    currentRow += rowSpan;
                }
            }
            
            return bricks;
        }

        function launchBall() {
            const angle = -Math.PI / 4 + (Math.random() * Math.PI / 4 - Math.PI / 8);
            const offsetX = (Math.random() - 0.5) * 200;
            return {
                x: canvas.width / 2 + offsetX,
                y: canvas.height / 2,
                vx: Math.cos(angle) * BALL_BASE_SPEED,
                vy: Math.sin(angle) * BALL_BASE_SPEED,
                active: true
            };
        }

        function addRandomMeeting() {
            // Add a new random meeting to a random day
            const day = Math.floor(Math.random() * 5);
            const colsPerDay = 3;
            const dayStartCol = day * colsPerDay;
            
            // Random height and width
            const rowSpan = Math.floor(Math.random() * 3) + 1;
            const height = rowSpan * BASE_BRICK_HEIGHT + (rowSpan - 1) * BRICK_PADDING;
            const colSpan = Math.min(Math.floor(Math.random() * 2) + 1, colsPerDay);
            const width = colSpan * BRICK_WIDTH + (colSpan - 1) * BRICK_PADDING;
            
            // Random y position in the meeting area
            const maxY = 300;
            const y = BRICK_OFFSET_TOP + Math.floor(Math.random() * (maxY - BRICK_OFFSET_TOP - height));
            
            gameState.bricks.push({
                x: BRICK_OFFSET_LEFT + dayStartCol * (BRICK_WIDTH + BRICK_PADDING),
                y: y,
                width: width,
                height: height,
                title: MEETING_TITLES[Math.floor(Math.random() * MEETING_TITLES.length)],
                color: MEETING_COLORS[Math.floor(Math.random() * MEETING_COLORS.length)],
                day: DAYS[day],
                active: true,
                points: rowSpan * 10
            });
        }

        function initGame() {
            gameState = {
                score: 0,
                gameOver: false,
                won: false,
                meetingsDestroyed: 0,
                paddle: {
                    x: canvas.width / 2 - PADDLE_WIDTH / 2,
                    vx: 0
                },
                balls: [],
                bricks: createBricks(),
                keys: {}
            };

            // Launch initial balls
            for (let i = 0; i < NUM_BALLS; i++) {
                gameState.balls.push(launchBall());
            }

            gameOverEl.style.display = 'none';
            highScoresEl.style.display = 'none';
            newHighScoreIndex = -1;
            scoreEl.textContent = 'Score: 0';
        }

        function drawBricks() {
            // Draw day headers
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = '#FFFFFF';
            const colsPerDay = 3;
            for (let day = 0; day < 5; day++) {
                const dayStartCol = day * colsPerDay;
                const x = BRICK_OFFSET_LEFT + dayStartCol * (BRICK_WIDTH + BRICK_PADDING) + (colsPerDay * BRICK_WIDTH) / 2;
                ctx.textAlign = 'center';
                ctx.fillText(DAYS[day], x, BRICK_OFFSET_TOP - 30);
            }
            
            // Draw time markers
            ctx.font = '10px Arial';
            ctx.fillStyle = '#888';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 10; i++) {
                const y = BRICK_OFFSET_TOP + i * (BASE_BRICK_HEIGHT + BRICK_PADDING);
                if (y < 380) {
                    const hour = 8 + i;
                    ctx.fillText(`${hour}:00`, BRICK_OFFSET_LEFT - 10, y + 5);
                }
            }
            
            // Draw meetings
            gameState.bricks.forEach(brick => {
                if (brick.active) {
                    // Draw meeting block
                    ctx.fillStyle = brick.color;
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    
                    // Add border
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                    
                    // Add subtle highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height * 0.3);
                    
                    // Draw meeting title
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    
                    const centerX = brick.x + brick.width / 2;
                    const centerY = brick.y + brick.height / 2 + 4;
                    
                    // Truncate text if needed
                    let displayText = brick.title;
                    ctx.textAlign = 'center';
                    const maxWidth = brick.width - 10;
                    
                    while (ctx.measureText(displayText).width > maxWidth && displayText.length > 0) {
                        displayText = displayText.slice(0, -1);
                    }
                    if (displayText.length < brick.title.length && displayText.length > 3) {
                        displayText = displayText.slice(0, -3) + '...';
                    }
                    
                    ctx.fillText(displayText, centerX, centerY);
                }
            });
        }

        function drawPaddle() {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(gameState.paddle.x, PADDLE_Y, PADDLE_WIDTH, PADDLE_HEIGHT);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(gameState.paddle.x, PADDLE_Y, PADDLE_WIDTH, PADDLE_HEIGHT / 3);
        }

        function drawBall(ball) {
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(ball.x - 2, ball.y - 2, BALL_RADIUS / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function updatePaddle() {
            if (gameState.keys['ArrowLeft']) {
                gameState.paddle.vx = -PADDLE_SPEED;
            } else if (gameState.keys['ArrowRight']) {
                gameState.paddle.vx = PADDLE_SPEED;
            } else {
                gameState.paddle.vx *= 0.8;
            }

            gameState.paddle.x += gameState.paddle.vx;

            if (gameState.paddle.x < 0) {
                gameState.paddle.x = 0;
                gameState.paddle.vx = 0;
            }
            if (gameState.paddle.x + PADDLE_WIDTH > canvas.width) {
                gameState.paddle.x = canvas.width - PADDLE_WIDTH;
                gameState.paddle.vx = 0;
            }
        }

        function updateBall() {
            // Update all balls
            for (let i = gameState.balls.length - 1; i >= 0; i--) {
                const ball = gameState.balls[i];
                
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Wall collisions (left and right)
                if (ball.x - BALL_RADIUS <= 0 || ball.x + BALL_RADIUS >= canvas.width) {
                    ball.vx = -ball.vx;
                    ball.x = Math.max(BALL_RADIUS, Math.min(canvas.width - BALL_RADIUS, ball.x));
                }

                // Top wall collision
                if (ball.y - BALL_RADIUS <= 0) {
                    ball.vy = -ball.vy;
                    ball.y = BALL_RADIUS;
                }

                // Bottom wall - ball fell
                if (ball.y - BALL_RADIUS > canvas.height) {
                    // Remove this ball
                    gameState.balls.splice(i, 1);
                    
                    // Add a new meeting
                    addRandomMeeting();
                    
                    // Spawn a new ball
                    gameState.balls.push(launchBall());
                    
                    continue;
                }

                // Paddle collision
                if (ball.y + BALL_RADIUS >= PADDLE_Y &&
                    ball.y - BALL_RADIUS <= PADDLE_Y + PADDLE_HEIGHT &&
                    ball.x >= gameState.paddle.x &&
                    ball.x <= gameState.paddle.x + PADDLE_WIDTH) {
                    
                    const hitPos = (ball.x - gameState.paddle.x) / PADDLE_WIDTH;
                    const angle = -Math.PI / 3 + (hitPos * (2 * Math.PI / 3));
                    const paddleSpeedBonus = Math.abs(gameState.paddle.vx) * 0.3;
                    const speed = BALL_BASE_SPEED + paddleSpeedBonus;
                    
                    ball.vx = Math.sin(angle) * speed;
                    ball.vy = -Math.cos(angle) * speed;
                    ball.y = PADDLE_Y - BALL_RADIUS;
                }

                // Brick collisions
                gameState.bricks.forEach(brick => {
                    if (!brick.active) return;

                    if (ball.x + BALL_RADIUS >= brick.x &&
                        ball.x - BALL_RADIUS <= brick.x + brick.width &&
                        ball.y + BALL_RADIUS >= brick.y &&
                        ball.y - BALL_RADIUS <= brick.y + brick.height) {
                        
                        brick.active = false;
                        gameState.score += brick.points;
                        gameState.meetingsDestroyed++;
                        scoreEl.textContent = 'Score: ' + gameState.score;

                        const ballCenterX = ball.x;
                        const ballCenterY = ball.y;
                        const brickCenterX = brick.x + brick.width / 2;
                        const brickCenterY = brick.y + brick.height / 2;

                        const dx = ballCenterX - brickCenterX;
                        const dy = ballCenterY - brickCenterY;

                        if (Math.abs(dx / brick.width) > Math.abs(dy / brick.height)) {
                            ball.vx = -ball.vx;
                        } else {
                            ball.vy = -ball.vy;
                        }
                    }
                });
            }

            // Check for win condition
            const activeBricks = gameState.bricks.filter(b => b.active).length;
            if (activeBricks === 0 && !gameState.won) {
                gameState.won = true;
                gameState.gameOver = true;
                handleGameOver();
            }
        }

        function getHighScores() {
            try {
                const scores = localStorage.getItem('breakoutHighScores');
                return scores ? JSON.parse(scores) : [];
            } catch (e) {
                console.log('Error reading from localStorage:', e);
            }
            return [];
        }

        function saveHighScores(scores) {
            localStorage.setItem('breakoutHighScores', JSON.stringify(scores));
            return true;
        }

        function addHighScore(newScore) {
            let highScores = getHighScores();
            highScores.push(newScore);
            highScores.sort((a, b) => b.score - a.score);
            
            const index = highScores.findIndex(s => 
                s.score === newScore.score && 
                s.meetings === newScore.meetings && 
                s.date === newScore.date
            );
            
            if (highScores.length > MAX_HIGH_SCORES) {
                highScores = highScores.slice(0, MAX_HIGH_SCORES);
            }
            
            saveHighScores(highScores);
            return index < MAX_HIGH_SCORES ? index : -1;
        }

        function displayHighScores() {
            const highScores = getHighScores();
            scoresBodyEl.innerHTML = '';
            
            if (highScores.length === 0) {
                scoresBodyEl.innerHTML = '<tr><td colspan="4" style="text-align: center;">No high scores yet!</td></tr>';
                return;
            }
            
            highScores.forEach((score, index) => {
                const row = document.createElement('tr');
                if (index === newHighScoreIndex) {
                    row.className = 'new-score';
                }
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${score.score}</td>
                    <td>${score.meetings}</td>
                    <td>${score.date}</td>
                `;
                scoresBodyEl.appendChild(row);
            });
        }

        function showHighScores() {
            displayHighScores();
            highScoresEl.style.display = 'block';
            gameOverEl.style.display = 'none';
        }

        function closeHighScores() {
            highScoresEl.style.display = 'none';
            newHighScoreIndex = -1;
        }

        function handleGameOver() {
            const finalScore = gameState.score;
            
            const newScore = {
                score: finalScore,
                meetings: gameState.meetingsDestroyed,
                date: new Date().toLocaleDateString()
            };
            
            newHighScoreIndex = addHighScore(newScore);
            
            if (gameState.won) {
                if (newHighScoreIndex !== -1) {
                    gameOverEl.innerHTML = `CALENDAR CLEARED!<br>NEW HIGH SCORE!<br><span style="font-size: 32px;">Score: ${finalScore} (Rank #${newHighScoreIndex + 1})</span><br><span style="font-size: 24px;">Meetings Destroyed: ${gameState.meetingsDestroyed}</span><br><span style="font-size: 20px;">Press SPACE to see high scores</span>`;
                } else {
                    gameOverEl.innerHTML = `CALENDAR CLEARED!<br><span style="font-size: 32px;">Final Score: ${finalScore}</span><br><span style="font-size: 24px;">Meetings Destroyed: ${gameState.meetingsDestroyed}</span><br><span style="font-size: 20px;">Press SPACE to see high scores</span>`;
                }
            } else {
                if (newHighScoreIndex !== -1) {
                    gameOverEl.innerHTML = `NEW HIGH SCORE!<br><span style="font-size: 32px;">Score: ${finalScore} (Rank #${newHighScoreIndex + 1})</span><br><span style="font-size: 24px;">Meetings Destroyed: ${gameState.meetingsDestroyed}</span><br><span style="font-size: 20px;">Press SPACE to see high scores</span>`;
                } else {
                    gameOverEl.innerHTML = `GAME OVER<br><span style="font-size: 32px;">Final Score: ${finalScore}</span><br><span style="font-size: 24px;">Meetings Destroyed: ${gameState.meetingsDestroyed}</span><br><span style="font-size: 20px;">Press SPACE to see high scores</span>`;
                }
            }
            gameOverEl.style.display = 'block';
        }

        function drawGame() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawBricks();
            drawPaddle();
            gameState.balls.forEach(ball => drawBall(ball));
        }

        function gameLoop() {
            if (!gameState.gameOver) {
                updatePaddle();
                updateBall();
            }
            
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;

            if (e.key === ' ') {
                e.preventDefault();
                if (highScoresEl.style.display === 'block') {
                    closeHighScores();
                    initGame();
                } else if (gameState.gameOver) {
                    showHighScores();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });

        initGame();
        gameLoop();
    </script>
</body>
</html>